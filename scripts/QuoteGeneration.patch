diff -purN SGXDataCenterAttestationPrimitives/QuoteGeneration/download_prebuilt.sh SGXDataCenterAttestationPrimitives_/QuoteGeneration/download_prebuilt.sh
--- SGXDataCenterAttestationPrimitives/QuoteGeneration/download_prebuilt.sh	2019-06-24 12:26:55.341632012 -0700
+++ SGXDataCenterAttestationPrimitives_/QuoteGeneration/download_prebuilt.sh	2019-06-13 00:07:17.000000000 -0700
@@ -39,14 +39,14 @@ server_ae_url=$server_url_path/$ae_file_
 server_checksum_url=$server_url_path/$checksum_file
 
 rm -rf $out_dir/$ae_file_name
-wget $server_ae_url -P $out_dir
+wget $server_ae_url -P $out_dir --no-check-certificate
 if [ $? -ne 0 ]; then
     echo "Fail to download file $server_ae_url"
     exit -1
 fi
 
 rm -f $out_dir/$checksum_file
-wget $server_checksum_url -P $out_dir
+wget $server_checksum_url -P $out_dir --no-check-certificate
 if [ $? -ne 0 ]; then
     echo "Fail to download file $server_checksum_url"
     exit -1
diff -purN SGXDataCenterAttestationPrimitives/QuoteGeneration/qcnl/sgx_default_qcnl_wrapper.cpp SGXDataCenterAttestationPrimitives_/QuoteGeneration/qcnl/sgx_default_qcnl_wrapper.cpp
--- SGXDataCenterAttestationPrimitives/QuoteGeneration/qcnl/sgx_default_qcnl_wrapper.cpp	2019-06-24 12:26:55.347632012 -0700
+++ SGXDataCenterAttestationPrimitives_/QuoteGeneration/qcnl/sgx_default_qcnl_wrapper.cpp	2019-06-13 00:07:17.000000000 -0700
@@ -35,6 +35,9 @@
  *
  */
 
+#include <iostream>
+#include <sstream>
+
 #include <string.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -290,49 +293,70 @@ static sgx_qcnl_error_t qcnl_https_get(c
     network_malloc_info_t res_header = {0,0};
     network_malloc_info_t res_body = {0,0};
 
+    printf("url:  %s\n", url);
+    
     do {
         curl = curl_easy_init();
-        if (!curl)
+        if (!curl){
+            std::cout << "curl_easy_init failed.\n"; 
             break;
+        }
 
-        if (curl_easy_setopt(curl, CURLOPT_URL, url) != CURLE_OK)
+        if (curl_easy_setopt(curl, CURLOPT_URL, url) != CURLE_OK){
+            std::cout << "curl_easy_setopt failed.\n";
             break;;
-
+        }
         if (!g_use_secure_cert) {
             // if not set this option, the below error code will be returned for self signed cert
             // CURLE_SSL_CACERT (60) Peer certificate cannot be authenticated with known CA certificates.
-            if (curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L) != CURLE_OK)
+            if (curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L) != CURLE_OK){
+                std::cout << "curl_easy_setopt 1 failed.\n";
                 break;
+            }
             // if not set this option, the below error code will be returned for self signed cert
             // // CURLE_PEER_FAILED_VERIFICATION (51) The remote server's SSL certificate or SSH md5 fingerprint was deemed not OK.
-            if (curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0L) != CURLE_OK)
+            if (curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0L) != CURLE_OK){
+                std::cout << "curl_easy_setopt 2 failed.\n";
                 break;
+            }
         }
 
         // Set write callback functions
-        if(curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback)!=CURLE_OK)
+        if(curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback)!=CURLE_OK){
+            std::cout << "curl_easy_setopt 3 failed.\n";
             break;
-        if(curl_easy_setopt(curl, CURLOPT_WRITEDATA, reinterpret_cast<void *>(&res_body))!=CURLE_OK)
+        }
+        
+        if(curl_easy_setopt(curl, CURLOPT_WRITEDATA, reinterpret_cast<void *>(&res_body))!=CURLE_OK){
+            std::cout << "curl_easy_setopt 4 failed.\n";
             break;
+        }
 
         // Set header callback functions
-        if(curl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, write_callback)!=CURLE_OK)
+        if(curl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, write_callback)!=CURLE_OK){
+            std::cout << "curl_easy_setopt 5 failed.\n";
             break;
-        if(curl_easy_setopt(curl, CURLOPT_HEADERDATA, reinterpret_cast<void *>(&res_header))!=CURLE_OK)
+        }
+        if(curl_easy_setopt(curl, CURLOPT_HEADERDATA, reinterpret_cast<void *>(&res_header))!=CURLE_OK){
+            std::cout << "curl_easy_setopt 6 failed.\n";
             break;
+        }
 
         // Perform request
         if((curl_ret = curl_easy_perform(curl))!=CURLE_OK) {
             ret = curl_error_to_qcnl_error(curl_ret);
+            std::cout << "curl_easy_perform failed. curl_rat = " << curl_ret << "ret = " << ret << "\n";
             break;
         }
         long http_code = 0;
         curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);
         if (http_code == 404) {
+            std::cout << "curl_easy_fetinfo failed. 404\n";
             ret = SGX_QCNL_ERROR_NO_CERT_DATA;
             break;
         }
         else if (http_code != 200) {
+            std::cout << "curl_easy_getinfo failed. http_code = " << http_code << "\n";
             ret = SGX_QCNL_UNEXPECTED_ERROR;
             break;
         }
@@ -440,21 +464,30 @@ sgx_qcnl_error_t sgx_qcnl_get_pck_cert_c
                                            sgx_ql_config_t **pp_quote_config)
 {
     sgx_qcnl_error_t  ret = SGX_QCNL_UNEXPECTED_ERROR;
+    uint8_t local_encrypted_ppid[384]={0};
+    std::cout << "sgx_qcnl_get_pck_cert_chain\n";
 
     // Check input parameters
     if (p_pck_cert_id == NULL || pp_quote_config == NULL) {
+        std::cout << "here 1\n";
         return SGX_QCNL_INVALID_PARAMETER;
     }
     if (p_pck_cert_id->p_qe3_id == NULL || p_pck_cert_id->qe3_id_size != QE3_ID_SIZE) {
+        std::cout << "here 2\n";
         return SGX_QCNL_INVALID_PARAMETER;
     }
     if (p_pck_cert_id->p_encrypted_ppid == NULL || p_pck_cert_id->encrypted_ppid_size != ENC_PPID_SIZE) {
-        return SGX_QCNL_INVALID_PARAMETER;
+        std::cout << "here 3\n";
+        if (p_pck_cert_id->p_encrypted_ppid == NULL) {
+            std::cout << "p_encrypted_ppid is NULL\n";
+        }        
     }
     if (p_pck_cert_id->p_platform_cpu_svn == NULL || p_pck_cert_id->p_platform_pce_isv_svn == NULL) {
+        std::cout << "here 4\n";
         return SGX_QCNL_INVALID_PARAMETER;
     }
     if (p_pck_cert_id->crypto_suite != PCE_ALG_RSA_OAEP_3072) {
+        std::cout << "here 5\n";
         return SGX_QCNL_INVALID_PARAMETER;
     }
 
@@ -464,13 +497,23 @@ sgx_qcnl_error_t sgx_qcnl_get_pck_cert_c
     // Append QE ID
     url.append("pckcert?qeid=");
     if ((ret = url_append_req_para(url, p_pck_cert_id->p_qe3_id, p_pck_cert_id->qe3_id_size)) != SGX_QCNL_SUCCESS) {
+        std::cout << "here 6\n";
         return ret;
     }
 
     // Append encrypted PPID
     url.append("&encrypted_ppid=");
-    if ((ret = url_append_req_para(url, p_pck_cert_id->p_encrypted_ppid, p_pck_cert_id->encrypted_ppid_size)) != SGX_QCNL_SUCCESS){
-        return ret;
+    if(p_pck_cert_id->p_encrypted_ppid == NULL){
+        if ((ret = url_append_req_para(url, (const uint8_t*)&local_encrypted_ppid, sizeof(local_encrypted_ppid))) != SGX_QCNL_SUCCESS){
+            std::cout << "here 6\n";
+            return ret;
+        }
+    }
+    else {
+        if ((ret = url_append_req_para(url, p_pck_cert_id->p_encrypted_ppid, p_pck_cert_id->encrypted_ppid_size)) != SGX_QCNL_SUCCESS){
+            std::cout << "here 7\n";
+            return ret;
+        }
     }
 
     // Append cpusvn
@@ -498,6 +541,7 @@ sgx_qcnl_error_t sgx_qcnl_get_pck_cert_c
 
     ret = qcnl_https_get(url.c_str(), &resp_msg, resp_size, &resp_header, header_size);
     if (ret != SGX_QCNL_SUCCESS) {
+        std::cout << "qcnl_https_get failed!  ret = " << ret << "\n";
         return ret;
     }
 
@@ -515,6 +559,7 @@ sgx_qcnl_error_t sgx_qcnl_get_pck_cert_c
         it = header_map.find("sgx-pck-certificate-issuer-chain");
         if (it == header_map.end()) {
             ret = SGX_QCNL_MSG_ERROR;
+            std::cout << "find(sgx-pck-certificate-issuer-chain):" << ret << "\n";
             break;
         }
         string certchain = it->second;
@@ -534,6 +579,7 @@ sgx_qcnl_error_t sgx_qcnl_get_pck_cert_c
         // set tcbm (cpusvn and pcesvn) 
         if (tcbm.size() != (CPUSVN_SIZE + PCESVN_SIZE)*2) {
             ret = SGX_QCNL_MSG_ERROR;
+            std::cout << "tcbm size is bad: " << ret << "\n";
             break;
         }
         if (!hex_string_to_byte_array(reinterpret_cast<const uint8_t*>(tcbm.data()), 
@@ -541,6 +587,7 @@ sgx_qcnl_error_t sgx_qcnl_get_pck_cert_c
                                       reinterpret_cast<uint8_t*>(&(*pp_quote_config)->cert_cpu_svn), 
                                       sizeof(sgx_cpu_svn_t))) {
             ret = SGX_QCNL_MSG_ERROR;
+             std::cout << "Error converting CPUSVN: " << ret << "\n";
             break;
         }
         if (!hex_string_to_byte_array(reinterpret_cast<const uint8_t*>(tcbm.data()+CPUSVN_SIZE*2), 
@@ -548,12 +595,14 @@ sgx_qcnl_error_t sgx_qcnl_get_pck_cert_c
                                       reinterpret_cast<uint8_t*>(&(*pp_quote_config)->cert_pce_isv_svn), 
                                       sizeof(sgx_isv_svn_t))) {
             ret = SGX_QCNL_MSG_ERROR;
+             std::cout << "Error converting pce isvsvn: " << ret << "\n";
             break;
         }
 
         // set certchain (leaf cert || intermediateCA || root CA)
         if (resp_size >= UINT32_MAX - (uint32_t)certchain.size()) {
             ret = SGX_QCNL_UNEXPECTED_ERROR;
+             std::cout << "resp size overflow: " << ret << "\n";
             break;
         }
 
@@ -580,7 +629,7 @@ sgx_qcnl_error_t sgx_qcnl_get_pck_cert_c
         free(resp_header);
         resp_header = NULL;
     }
-
+    std::cout << "end QCNL. ret = " << ret << "\n";
     return ret;
 }
 
@@ -706,7 +755,7 @@ void sgx_qcnl_free_pck_crl_chain(uint8_t
 /**
 * This API gets TCB information from PCS server. The p_tcbinfo buffer allocated by this API
 * must be freed with sgx_qcnl_free_tcbinfo upon success.
-*
+l
 * @param fmspc Family-Model-Stepping value
 * @param fmspc_size Size of the fmspc buffer
 * @param p_tcbinfo Output buffer for TCB information
