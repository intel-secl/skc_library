#!/bin/bash
set -e 

#**********************************************************************************************************************
#**********************************************************************************************************************
#									DHSM_2.0_CREDENTIAL_AGANT_COMMANDLINE_TOOL
#**********************************************************************************************************************
#**********************************************************************************************************************
##=====================================================================================================================
##COMMON_UTILS
##=====================================================================================================================
readonly UTIL_SCRIPT="__PREFIX__/bin/credential-agent/common_utils"

if [ -f $UTIL_SCRIPT ]; then
	source $UTIL_SCRIPT
	log_msg $LOG_DEBUG "Utils included"
else
	exit $CODE_IO_FAILURE
fi

#======================================================================================================================
#VARAIBALE/CONSTANT
#=====================================================================================================================

#VARIABLE
declare FLAG_OPERATION=""
declare FLAG_FORCE=$FLAG_DISABLE
declare tmp_dir="__PREFIX__/tmp"
declare CRED_CONF_FILE="__PREFIX__/etc/credential_agent.ini"
declare client_openssl_conf="$tmp_dir/engines.cnf"
declare csr_output="$tmp_dir/csr_output.txt"
declare csr_file="/opt/skc/bin/csr_file"
declare -A pkcs11_url_dict

#=====================================================================================================================


is_token_present()
{

        local token_label="$1"
        local cnt=$(pkcs11-tool --module ${pkcs11_module} -L | grep 'token label' | grep -c "\<$token_label\>")
        echo $cnt
}

get_slot_no_by_token()
{
        local token_label="$1"
        local token_present=$(is_token_present "$token_label")
        local slot=-1
        log_msg $LOG_DEBUG "token present:$token_present, $token_label"
        if [ $token_present -eq 1 ]; then
                slot=$(pkcs11-tool --module ${pkcs11_module} -L |  tr '\n' '@' | sed -e "s/.*SoftHSM slot \(.*\)@\s\+token label\s\+: ${token_label}@.*/\1/")
                log_msg $LOG_DEBUG "token:$token_label is present and slot id:$slot"
                echo $slot
        else
                log_msg $LOG_DEBUG "token:$token_label not present"
                echo $slot
        fi
}

get_uninitialzied_slot()
{

        local unintialized_slot=$(pkcs11-tool --module ${pkcs11_module} -L |  tr '\n' '@' | sed -e "s/.*SoftHSM slot \(.*\)@\s\+token state:\s\+uninitialized@/\1/g")
	log_msg $LOG_DEBUG "Unitialized slot:$unintialized_slot"
        echo $unintialized_slot

}

parse_pkcs11_keyid()
{
    read -a keyid <<< $(echo "${pkcs11_url_dict[id]}"| sed -e 's/%/ /g')
    for id in $(seq 0 `expr ${#keyid[@]} - 1`); do
        keyid[$id]=`echo $(( ${keyid[$id]} + 0 ))`;
    done
    pkcs11_url_dict[id]=`echo ${keyid[@]} | sed -e 's/ //g'`;
}

parse_pkcsll_url()
{
    read -a arr <<< $(echo "$certificate_key"| sed -e 's/;\|=/ /g' | sed -e 's/.*://')
    local count=`expr ${#arr[@]} - 1`;
    for i in $(seq 0 $count); do
      t2=`expr $i % 2`;

      if [ $i -eq 0 ] && [ $i -ne 1 ] || [ $t2 -eq 0 ]; then
        t=${arr[$i]};
        pkcs11_url_dict[$t]=${arr[$i+1]};
        log_msg $LOG_DEBUG "Itr:$i, key:${arr[$i]}, value:${pkcs11_url_dict[$t]}"
      else
        continue;
      fi
    done
	parse_pkcs11_keyid
	echo ${pkcs11_url_dict}
}

read_conf_file()
{
	if [ -f "$CRED_CONF_FILE" ]; then
		#log_msg $LOG_DEBUG "Configuration file :$CRED_CONF_FILE"
		source $CRED_CONF_FILE
	else 
		exit_script $LOG_ERROR "Invalid configuration file path: $CRED_CONF_FILE" $CODE_IO_FAILURE
	fi
}

parse_cert_output()
{
	if [ -f "$csr_output" ]; then
		log_msg $LOG_DEBUG "file is present"
		local line=$(head -n 1 $csr_output)
		if [ "$line" = "-----BEGIN CERTIFICATE-----" ]; then
			csr_response_cert=$(cat $csr_output | sed -e 's/^.*certificate":"\(.*\)"}}/\1/'  -e 's/\\n/\n/g' >  $certificate)
		else
			response=$(<$csr_output)
			exit_script $LOG_ERROR "Command Response: $response, execution" $CODE_EXEC_ERROR
		fi
	else
		exit_script $LOG_ERROR "CSR command execution failed" $CODE_EXEC_ERROR
	fi
}

create_store_directory()
{
	local cmd="mkdir -p ${store_dir} && mkdir -p ${tmp_dir}"
	$(check_last_cmd_exec_status "$cmd" $EXEC_RULE_ABORT "Store dir genration" $CODE_OPENSSL_ERROR)
}

gen_openssl_config()
{

	local dynamic_engine_path=`find /usr/lib* -name 'pkcs11.so' | head -n 1`;
	printf "HOME            = .
RANDFILE        = $ENV::HOME/.rnd

openssl_conf = openssl_def

[openssl_def]
engines = engine_section

[engine_section]
pkcs11 = pkcs11_section

[pkcs11_section]
engine_id = pkcs11
dynamic_path = ${dynamic_engine_path}
MODULE_PATH = ${pkcs11_module}
init = 0

[ req ]
distinguished_name = req_dn
string_mask = utf8only
utf8 = yes

[ req_dn ]
commonName = intel.com" > ${client_openssl_conf}

}

gen_and_get_csr_buf()
{
    local cmd="";
    local operation="$1";
    local csr_content="";
    local softhsm_utils="softhsm2-util"
    local client_root_certificate="$tmp_dir/client_certificate.pem" 

    local slot=-1

    log_msg $LOG_DEBUG "Operation ${operation}"


    if [ "${keyformat}" = "PEMFILE" ]; then
		if [ "${operation}" = "issue" ]; then
			cmd="openssl genrsa -out ${certificate_key} ${keysize} &> /dev/null"
			$(check_last_cmd_exec_status "$cmd" $EXEC_RULE_ABORT "RSA Key Generation" $CODE_OPENSSL_ERROR);
			cmd="openssl req  -nodes -new -x509 -subj \"${request_params}\" -sha384 -key ${certificate_key} -out ${client_root_certificate} &> /dev/null";
                        $(check_last_cmd_exec_status "$cmd" $EXEC_RULE_ABORT "Client Root Cert Generation" $CODE_OPENSSL_ERROR);
		fi
		cmd="openssl x509 -x509toreq -in ${client_root_certificate} -out ${csr} -signkey ${certificate_key} -sha384 > /dev/null";
		$(check_last_cmd_exec_status "$cmd" $EXEC_RULE_ABORT "CSR Genration Generation" $CODE_OPENSSL_ERROR)

    elif [ "${keyformat}" = "PKCS11" ]; then
		
	    parse_pkcsll_url

		if [ "${operation}" = "issue" ]; then
		
		        slot=$(get_slot_no_by_token "${pkcs11_url_dict[token]}")
			if [ $slot -ne -1 ]; then
				cmd="${softhsm_utils} --module ${pkcs11_module} --delete-token --slot ${slot} \
                                      --token \"${pkcs11_url_dict[token]}\" &> /dev/null"
			        $(check_last_cmd_exec_status "$cmd" $EXEC_RULE_WARN "Delete slot" $CODE_EXEC_WARN)
			else
				slot=$(get_uninitialzied_slot)
			fi

			cmd="${softhsm_utils} --module ${pkcs11_module} --init-token  --label \"${pkcs11_url_dict[token]}\" \
				 --slot ${slot} --pin \"${pkcs11_url_dict[pin-value]}\" \
                                 --so-pin \"${pkcs11_url_dict[pin-value]}\" &> /dev/null"
			$(check_last_cmd_exec_status "$cmd" $EXEC_RULE_ABORT "Init slot" $CODE_EXEC_ERROR)

			cmd="pkcs11-tool --module ${pkcs11_module} --login --pin \"${pkcs11_url_dict[pin-value]}\" \
			--id \"${pkcs11_url_dict[id]}\" --token \"${pkcs11_url_dict[token]}\"  --keypairgen \
			--key-type $keytype:$keysize --label \"${pkcs11_url_dict[object]}\"  --usage-sign &> /dev/null"
			$(check_last_cmd_exec_status "$cmd" $EXEC_RULE_ABORT "Key Pair Gen-SLOT:$cmd" $CODE_EXEC_ERROR)

		
			gen_openssl_config

			cmd="openssl req -new -x509 -days 365 -subj \"$request_params\" -sha256 -config \
				 ${client_openssl_conf} -engine pkcs11 -keyform engine \
				 -key \"${certificate_key}\" \
				 -new -out ${client_root_certificate} &> /dev/null";
			$(check_last_cmd_exec_status "$cmd" $EXEC_RULE_ABORT "Client Root Cert Generation:$cmd" $CODE_EXEC_ERROR)
		fi

		cmd="OPENSSL_CONF=${client_openssl_conf} openssl x509 \
				-engine pkcs11 -keyform engine \
				-in ${client_root_certificate} \
				-signkey \"${certificate_key}\" \
				-x509toreq \
				-outform pem \
				-out ${csr} &> /dev/null";

        $(check_last_cmd_exec_status "$cmd" $EXEC_RULE_ABORT "CSR Generation" $CODE_EXEC_ERROR)
    else
		exit_script $LOG_DEBUG "Check invalid keyformat:${keyformat}\n" $CODE_EXEC_ERROR
    fi
	csr_content=$(awk '/-----BEGIN CERTIFICATE REQUEST-----/,/-----END CERTIFICATE REQUEST-----/' ${csr} | tr '\r\n' '@' | sed -e 's/@/\\n/g')
	log_msg $LOG_DEBUG "CSR Generation completed:" 
	echo "$csr_content"
}

get_cert_buf()
{
	local cert_content=$(cat $certificate | tr '\r\n' '@' | sed -e 's/@/\\n/g' )
	echo "$cert_content"
}

issue_certificate()
{
	local csr_content=$(gen_and_get_csr_buf "issue")

	local trimmed_content=$(echo $csr_content | sed '/^$/d' );
	echo $trimmed_content > $csr_file
	sed -i 's/\\n/\n/g' $csr_file
	export csr_data=`cat $csr_file`
	local issue_cert_cmd="curl -X POST -v 'https://$server:$port/cms/v1/certificates?certType=TLS' \
				  -H 'Content-Type: application/x-pem-file' \
				  -H 'Accept: application/x-pem-file' \
				  -H \"Authorization: Bearer $token\" \
				   --cacert $ca_cert \
				  -d \"$csr_data\" \
				  > $csr_output"
	$(check_last_cmd_exec_status "$issue_cert_cmd" $EXEC_RULE_ABORT "CS CSR Request" $CODE_EXEC_ERROR)
	parse_cert_output 
	update_keyagent_conf
	exit_script $LOG_OK "Issue Certificate" $CODE_EXEC_SUCCESS
}

update_keyagent_conf()
{
	local cmd="";
	cmd="sed -i \"s|\(^keyformat=\).*|\1${keyformat}|g\" ${keyagent_conf}"
	$(check_last_cmd_exec_status "$cmd" $EXEC_RULE_ABORT "CS:Update keyformat" $CODE_EXEC_ERROR)
	cmd="sed -i \"s|\(^certificate=\).*|\1${certificate}|g\" ${keyagent_conf}"
	$(check_last_cmd_exec_status "$cmd" $EXEC_RULE_ABORT "CS:Update certificate" $CODE_EXEC_ERROR)
	cmd="sed -i \"s|\(^certificate_key=\).*|\1${certificate_key}|g\" ${keyagent_conf}"
	$(check_last_cmd_exec_status "$cmd" $EXEC_RULE_ABORT "CS:Update certificate key" $CODE_EXEC_ERROR)
}
is_validity_expired()
{
	local is_cert_abt_to_exp="openssl x509 -checkend $cert_validity -noout -in $certificate"
	eval $is_cert_abt_to_exp
	echo $?
}

renew_certificate()
{
	local lstatus=$(is_validity_expired)
	if [ $lstatus -eq 0 ] && [ $FLAG_FORCE -eq $FLAG_DISABLE ]; then
		log_msg $LOG_DEBUG "Certificate Validity exists:$cert_validity secs" 
		exit $CODE_EXEC_SUCCESS
	fi

	local csr_content=$(gen_and_get_csr_buf "renew")
	local trimmed_content=$(echo $csr_content | sed '/^$/d' );
	local cert_content=$(get_cert_buf)
	local renew_cert_cmd=""

    if [ "${keyformat}" = "PEMFILE" ]; then
		renew_cert_cmd="curl -X POST \"https://$server:$port/v1/csr/\" \
						 -H 'Content-Type: application/json' \
						 -H 'Accept: application/json' \
						 -d '{\"certificate_request\":\"${trimmed_content}\"}' \
						 --cert ${certificate} \
						 --key ${certificate_key} \
						 --cacert $ca_cert \
						 > $csr_output"
    elif [ "${keyformat}" = "PKCS11" ]; then
		renew_cert_cmd="OPENSSL_CONF=${client_openssl_conf} ${curl_pkcs11} -X POST \"https://$server:$port/v1/csr/\" \
						 -H 'Content-Type: application/json' \
						 -H 'Accept: application/json' \
						 -d '{\"certificate_request\":\"${trimmed_content}\" }' \
						 --cert ${certificate} \
						 --engine pkcs11 --key-type ENG \
						 --key \"${certificate_key}\" \
						 --cacert $ca_cert \
						 > $csr_output"
	fi
	check_last_cmd_exec_status "$renew_cert_cmd" $EXEC_RULE_ABORT "Renew Certificate with Credential Service" $CODE_EXEC_ERROR
	parse_cert_output 
	exit_script $LOG_OK "Renew Certificate" $CODE_EXEC_SUCCESS
}

usage()
{
	log_msg $LOG_WARN "$0 [ --get-certificate | --renew-certificate ] [--force] [--verbose] \
							   [ --config <pathnanme-to-configuration-file> ]"	
	exit_script $LOG_WARN "Invalid commandline args" $CODE_PARSE_ERROR
}


lock 200 $(basename $0) || exit $CODE_CONCURRENCY_ERROR
trap 'send_status' 1 2 3 6
while [ "$1" != "" ]; do
	case $1 in
		--get-certificate )     FLAG_OPERATION="CSR"
								;;
		--renew-certificate )   FLAG_OPERATION="RENEW"
								;;
		--force )     			FLAG_FORCE=$FLAG_ENABLE
								;;
		--verbose )   			set_log $FLAG_ENABLE
								;;
		--config )   			shift
								CRED_CONF_FILE=$1
								;;
		-h | --help )           usage
								;;
		*)                      usage
	esac
	shift
done

read_conf_file
log_var=$(get_log)
if [[ $log_var -eq $FLAG_ENABLE ]]; then
	set_log_file "$credential_agent_log"
fi

create_store_directory

if [ "$FLAG_OPERATION" == "CSR" ]; then
	if [ -f "$certificate" ] && [ $FLAG_FORCE -eq $FLAG_DISABLE ]; then
		exit_script $LOG_WARN "Certificate already present, CSR" $CODE_EXEC_WARN
	else
		issue_certificate
	fi
elif [ "$FLAG_OPERATION" == "RENEW" ]; then
	if [ -f "$certificate" ]; then
		renew_certificate
	else
		exit_script $LOG_ERROR "Certificate not present, Renew" $CODE_EXEC_WARN
	fi
else
	usage
fi
exit_script $LOG_OK "Commandline Tool Exited" $CODE_EXEC_SUCCESS
